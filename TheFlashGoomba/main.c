#include "main.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "gba.h"
#include "animation.h"
#include "collision.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// IMAGES
#include "images/titleScreen.h"

#include "images/goombaTiles/GoombaIdle.h"
#include "images/goombaTiles/GoombaShuffle.h"
#include "images/goombaTiles/GoombaJump.h"

#include "images/goombaTiles/hurt/GoombaHurtIdle.h"
#include "images/goombaTiles/hurt/GoombaHurtShuffle.h"
#include "images/goombaTiles/hurt/GoombaHurtJump.h"

#include "images/koopaTiles/koopaIdle.h"
#include "images/koopaTiles/koopaRun.h"

#include "images/forcefieldTiles/Forcefield1.h"
#include "images/forcefieldTiles/Forcefield2.h"
#include "images/forcefieldTiles/Forcefield3.h"

#include "images/platformTiles/platform1.h"
#include "images/platformTiles/platform2.h"
#include "images/platformTiles/platform3.h"

#include "images/fireballTiles/Fireball1.h"
#include "images/fireballTiles/Fireball2.h"

#include "images/marioTiles/MarioIdle.h"
#include "images/marioTiles/Mario1.h"
#include "images/marioTiles/Mario2.h"
#include "images/marioTiles/Mario3.h"
#include "images/marioTiles/Mario4.h"
#include "images/marioTiles/MarioIdleHurt.h"

#include "images/icons/GoombaIconAlive.h"
#include "images/icons/GoombaIconDead.h"
#include "images/icons/MarioIconAlive.h"
#include "images/icons/MarioIconDead.h"

#include "images/titleScreenTiles/titleScreenF1.h"
#include "images/titleScreenTiles/titleScreenF2.h"
#include "images/titleScreenTiles/titleScreenF3.h"
#include "images/titleScreenTiles/titleScreenF4.h"
#include "images/titleScreenTiles/titleScreenF5.h"
#include "images/titleScreenTiles/titleScreenF6.h"
#include "images/titleScreenTiles/titleScreenF7.h"
#include "images/titleScreenTiles/titleScreenF8.h"

#include "images/loseTiles/Lose1.h"
#include "images/loseTiles/Lose2.h"
#include "images/loseTiles/Lose3.h"
#include "images/loseTiles/Lose4.h"
#include "images/loseTiles/Lose5.h"
#include "images/loseTiles/LoseIdle.h"

#include "images/winTiles/Win1.h"
#include "images/winTiles/Win2.h"
#include "images/winTiles/Win3.h"
#include "images/winTiles/Win4.h"
#include "images/winTiles/Win5.h"
#include "images/winTiles/Win6.h"
#include "images/winTiles/Win7.h"
#include "images/winTiles/Win8.h"
#include "images/winTiles/Win9.h"
#include "images/winTiles/Win10.h"
#include "images/winTiles/WinIdle.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

void drawPastBox(struct object obj);

int main(void) {

  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  // ---------------------------------------------------------------------------
  //                       ANIMATION SETUP
  // ---------------------------------------------------------------------------
  const u16 *titleScreenAnimation[] = {TitleScreenF1, TitleScreenF2, TitleScreenF3, TitleScreenF4, TitleScreenF5, TitleScreenF6, TitleScreenF7, TitleScreenF8};
  struct frames titleScreenFrames;
  startAnimation(&titleScreenFrames, titleScreenAnimation, sizeof(titleScreenAnimation) / sizeof(titleScreenAnimation[0]), WIDTH, HEIGHT);

  const u16 *loseScreenAnimation[] = {Lose1, Lose2, Lose3, Lose4, Lose5, LoseIdle};
  struct frames loseScreenFrames;
  startAnimation(&loseScreenFrames, loseScreenAnimation, sizeof(loseScreenAnimation) / sizeof(loseScreenAnimation[0]), WIDTH, HEIGHT);

  const u16 *winScreenAnimation[] = {Win1, Win2, Win3, Win4, Win5, Win6, Win7, Win8, Win9, Win10, WinIdle};
  struct frames winScreenFrames;
  startAnimation(&winScreenFrames, winScreenAnimation, sizeof(winScreenAnimation) / sizeof(winScreenAnimation[0]), WIDTH, HEIGHT);

  const u16 *shuffleAnimation[] = {GoombaIdle, GoombaShuffle};
  const u16 *shuffleAnimationPain[] = {GoombaHurtIdle, GoombaHurtShuffle};

  struct frames goombaShuffle;
  struct frames goombaShufflePain;
  startAnimation(&goombaShuffle, shuffleAnimation, sizeof(shuffleAnimation) / sizeof(shuffleAnimation[0]), GOOMBAIDLEPNG_WIDTH, GOOMBAIDLEPNG_HEIGHT);
  startAnimation(&goombaShufflePain, shuffleAnimationPain, sizeof(shuffleAnimationPain) / sizeof(shuffleAnimationPain[0]), GOOMBAIDLEPNG_WIDTH, GOOMBAIDLEPNG_HEIGHT);

  const u16 *koopaAnimation[] = {KoopaIdle, KoopaRun};
  struct frames koopaRun;
  startAnimation(&koopaRun, koopaAnimation, sizeof(koopaAnimation) / sizeof(koopaAnimation[0]), KOOPAIDLE_WIDTH, KOOPAIDLE_HEIGHT);

  const u16 *marioAnimation[] = {MarioIdle, Mario1, Mario2, Mario3, Mario4};
  struct frames marioFireballThrow;
  startAnimation(&marioFireballThrow, marioAnimation, sizeof(marioAnimation) / sizeof(marioAnimation[0]), MARIO1_WIDTH, MARIO1_HEIGHT);

  const u16 *fireballAnimation[] = {Fireball1, Fireball2};
  struct frames marioFireball;
  startAnimation(&marioFireball, fireballAnimation, sizeof(fireballAnimation) / sizeof(fireballAnimation[0]), FIREBALL1_WIDTH, FIREBALL1_HEIGHT);

  const u16 *jumpFrame = GoombaJump;
  const u16 *jumpFramePain = GoombaHurtJump;
  const u16 *marioFramePain = MarioIdleHurt;

  const u16 *forcefieldAnimation[] = {Forcefield1, Forcefield2, Forcefield3};
  struct frames forcefieldFrames;
  startAnimation(&forcefieldFrames, forcefieldAnimation, sizeof(forcefieldAnimation) / sizeof(forcefieldAnimation[0]), FORCEFIELD3_WIDTH, FORCEFIELD3_HEIGHT);

  const u16 *platformAnimation[] = {Platform1, Platform2, Platform3};
  struct frames platformFrames;
  startAnimation(&platformFrames, platformAnimation, sizeof(platformAnimation) / sizeof(platformAnimation[0]), PLATFORM1_WIDTH, PLATFORM1_HEIGHT);

  //const u16 *marioIcons[] = {MarioIconAlive, MarioIconDead};
  //const u16 *goombaIcons[] = {GoombaIconAlive, GoombaIconDead};
  //struct frames goombaIconFrames;
  //startAnimation(&goombaIconFrames, goombaIcons, sizeof(goombaIcons) / sizeof(goombaIcons[0]), GOOMBAICONALIVE_WIDTH, GOOMBAICONALIVE_HEIGHT);

  //struct frames marioIconFrames;
  //startAnimation(&marioIconFrames, marioIcons, sizeof(marioIcons) / sizeof(marioIcons[0]), MARIOICONALIVE_WIDTH, MARIOICONALIVE_HEIGHT);
  char numLivesStr[sizeof(int) * 8 + 1];
  char marioLivesStr[sizeof(int) * 8 + 1];
  char totalScoreStr[sizeof(int) * 8 + 1];
  struct position numLivesPos;
  numLivesPos.x = 0;
  numLivesPos.y = 2;
  struct position marioLivesPos;
  marioLivesPos.x = numLivesPos.x;
  marioLivesPos.y = numLivesPos.y + TEXT_H;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //

    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START:

        srand(time(NULL)); //seed random to current time :)

        // ---------------------------------------------------------------------------
        //                       ANIMATION RESET
        // ---------------------------------------------------------------------------
        goombaShuffle.currentFrame = 0;
        goombaShufflePain.currentFrame = 0;
        koopaRun.currentFrame = 0;
        marioFireballThrow.currentFrame = 0;
        marioFireball.currentFrame = 0;
        forcefieldFrames.currentFrame = 0;
        platformFrames.currentFrame = 0;
        loseScreenFrames.currentFrame = 0;
        winScreenFrames.currentFrame = 0;
        // ---------------------------------------------------------------------------
        //                       OBJECT SETUP
        // ---------------------------------------------------------------------------
      
        //FORCEFIELD
        struct forcefield forcefields[MAX_FORCEFIELDS];
        for (int i = 0; i < MAX_FORCEFIELDS; i++){
          forcefields[i].frames = forcefieldFrames;
          forcefields[i].collider.width = FORCEFIELD3_WIDTH;
          forcefields[i].collider.height = FORCEFIELD3_HEIGHT;
          forcefields[i].isActive = 0;
          forcefields[i].timeActive = 0;
        }
        int numForcefields = 0;
      
        //PLATFORMS
        struct platform platforms[MAX_PLATFORMS];
        for (int i = 0; i < MAX_PLATFORMS; i++){
          platforms[i].frames = platformFrames;
          platforms[i].collider.width = PLATFORM1_WIDTH;
          platforms[i].collider.height = PLATFORM1_HEIGHT;
          platforms[i].collider.pos.x = WIDTH - (PLATFORM1_WIDTH * (i));
          platforms[i].collider.pos.y = HEIGHT - platforms[i].collider.height;
        }
      
        int ground = platforms[0].collider.pos.y - platforms[0].collider.height - GOOMBAIDLEPNG_HEIGHT/2;
      
        //GOOMBA
        struct object goomba;
        goomba.frames = goombaShuffle;
        goomba.collider.pos.x = (WIDTH - GOOMBAIDLEPNG_WIDTH) / 2;
        goomba.kinematics.vx = 3;
        goomba.collider.pos.y = ground;
        goomba.kinematics.vyo = -10;
        goomba.kinematics.vy = 0;
        goomba.collider.height = GOOMBAIDLEPNG_HEIGHT;
        goomba.collider.width = GOOMBAIDLEPNG_WIDTH;
        goomba.isActive = 1;
        goomba.hasChanged = 0;
      
        char canJump = 1;
        int numLives = MAX_GOOMBA_LIVES;
        int iframesTime = -1;

        char scoreUpdated = 0;
        
        //KOOPA
        struct object koopas[MAX_KOOPAS];
        for (int i = 0; i < MAX_KOOPAS; i++){
          koopas[i].frames = koopaRun;
          koopas[i].kinematics.vx = 2;
          koopas[i].collider.pos.y = ground;
          koopas[i].kinematics.vyo = 0;
          koopas[i].kinematics.vy = 0;
          koopas[i].collider.height = KOOPAIDLE_HEIGHT;
          koopas[i].collider.width = KOOPAIDLE_WIDTH;
          koopas[i].collider.pos.x = WIDTH - koopas[i].collider.width;
          koopas[i].isActive = 0;
          koopas[i].hasChanged = 0;
        }
        int numKoopas = 0;

        //MARIO
        struct object mario;
        mario.frames = marioFireballThrow;
        mario.collider.pos.x = 0;
        mario.kinematics.vx = 2;
        mario.kinematics.vyo = 0;
        mario.kinematics.vy = 0;
        mario.collider.height = MARIO1_HEIGHT;
        mario.collider.width = MARIO1_WIDTH;
        mario.collider.pos.y = goomba.collider.pos.y - mario.collider.height / 2;
        mario.isActive = 1;
        mario.hasChanged = 0;
        
        int marioLives = MAX_MARIO_LIVES;
        int hitDuration = -1;

        //FIREBALL
        struct object fireball;
        fireball.frames = marioFireball;
        fireball.kinematics.vx = 3;
        fireball.kinematics.vyo = 0;
        fireball.kinematics.vy = 0;
        fireball.collider.height = FIREBALL1_HEIGHT;
        fireball.collider.width = FIREBALL1_WIDTH;
        fireball.collider.pos = mario.collider.pos;
        fireball.isActive = 0;
        fireball.hasChanged = 0;
      
        int timer = 0;
      
        updateAnimation(&titleScreenFrames);
        drawAnimation(&titleScreenFrames, 0, 0);

        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          fillScreenDMA(SKY);
        }
      break;

      case PLAY:
        
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          titleScreenFrames.currentFrame = 0; //reset title screen animation
        }

        // ---------------------------------------------------------------------------
        //                                    UPDATE - PLAYER
        // ---------------------------------------------------------------------------

        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          drawPastBox(goomba);
          goomba.collider.pos.x -= goomba.kinematics.vx;
          
          //Bounds - X
          if (goomba.collider.pos.x < 0) {
            goomba.collider.pos.x = 0;
          } 

          goomba.hasChanged = 1;
        }

        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          drawPastBox(goomba);
          goomba.collider.pos.x += goomba.kinematics.vx;
          //Bounds - X
          if (goomba.collider.pos.x > WIDTH - goomba.collider.width) {
            goomba.collider.pos.x = WIDTH - goomba.collider.width;
          }

          goomba.hasChanged = 1;
        }

        //Gravity + Jumping Mechanics
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) && canJump != 0) {
          goomba.kinematics.vy = goomba.kinematics.vyo;
          canJump = 0;
        } 

        drawPastBox(goomba);
        goomba.kinematics.vy += GRAVITY;
        goomba.collider.pos.y += goomba.kinematics.vy;

        //Bounds - Y
        if (goomba.collider.pos.y < 0) {
          goomba.collider.pos.y = 0;
        }

        if (goomba.collider.pos.y > ground) { //reset jump at ground level
          goomba.kinematics.vy = 0;
          goomba.collider.pos.y = ground;
          canJump = 1; //enable jumping again
        }
        
          
        //Forcefield Deployment
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) &&
        !KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          if (numForcefields < MAX_FORCEFIELDS){
            int i = 0;
            while (forcefields[i].isActive == 1) {
              i++;
              if (forcefields[i].collider.pos.x == goomba.collider.pos.x + GOOMBAIDLEPNG_WIDTH / 2  - forcefields[i].collider.width / 2 &&
                forcefields[i].collider.pos.y == goomba.collider.pos.y + GOOMBAIDLEPNG_HEIGHT - forcefields[i].collider.height) {
                  break;
              }
            }
            forcefields[i].isActive = 1;
            forcefields[i].collider.pos.x = goomba.collider.pos.x + GOOMBAIDLEPNG_WIDTH / 2  - forcefields[i].collider.width / 2;
            forcefields[i].collider.pos.y = goomba.collider.pos.y + GOOMBAIDLEPNG_HEIGHT - forcefields[i].collider.height;
            numForcefields++;
          }
        }

        for (int i = 0; i < MAX_FORCEFIELDS; i++){
          if (forcefields[i].isActive) {
            drawRectDMA(forcefields[i].collider.pos.y, forcefields[i].collider.pos.x, forcefields[i].collider.width, forcefields[i].collider.height, SKY);
          }
        }

        //Koopa Deployment
        if (timer % (KOOPA_SPAWN_RATE * FRAME_RATE) == 0) {
          if (numKoopas < MAX_KOOPAS){
            int i = 0;
            while (koopas[i].isActive == 1) {
              i++;
            }
            koopas[i].isActive = 1;
            int side = (rand() % (2));
            if (side % 2 == 0) {
              koopas[i].collider.pos.x = WIDTH - koopas[i].collider.width;
            } else {
              koopas[i].collider.pos.x = 0;
            }
            
            koopas[i].collider.pos.y = ground - abs(goomba.collider.height - koopas[i].collider.height);
            numKoopas++;
          }
        } 

        //Fireball Deployment
        if (timer % ((FIREBALL_RATE / (marioLives - MAX_MARIO_LIVES + 1)) * FRAME_RATE) == 0 && !fireball.isActive) {
          fireball.isActive = 1;
          fireball.kinematics.vx = abs(fireball.kinematics.vx);
          drawPastBox(mario);
          int side = (rand() % (2));
          if (side % 2 == 0){
            mario.collider.pos.x = WIDTH - mario.collider.width;
            fireball.kinematics.vx = -fireball.kinematics.vx;
            fireball.collider.pos.x = mario.collider.pos.x - fireball.collider.width;
          } else {
            mario.collider.pos.x = 0;
            fireball.collider.pos.x = mario.collider.pos.x + fireball.collider.width;
          }  
          fireball.collider.pos.y = mario.collider.pos.y;
        }
        // ---------------------------------------------------------------------------
        //                                    UPDATE - FORCEFIELD
        // ---------------------------------------------------------------------------
        for (int i = 0; i < MAX_FORCEFIELDS; i++){
          if (forcefields[i].isActive != 0) {
            if (forcefields[i].timeActive >= MAX_FORCEFIELD_TIME * FRAME_RATE) {
              forcefields[i].timeActive = 0;
              forcefields[i].isActive = 0;
              forcefields[i].frames.currentFrame = 0;
              numForcefields--;
            }
            forcefields[i].timeActive++;
          }
        }

        // ---------------------------------------------------------------------------
        //                                    UPDATE - ENEMIES
        // ---------------------------------------------------------------------------

        //Koopa Movement
        for (int i = 0; i < MAX_KOOPAS; i++) {
          if (koopas[i].isActive) {
            drawPastBox(koopas[i]);
            koopas[i].collider.pos.x += koopas[i].kinematics.vx;
            //Bounds - "bounce" around screen
            if (koopas[i].collider.pos.x > WIDTH - koopas[i].collider.width) {
              koopas[i].collider.pos.x = WIDTH - koopas[i].collider.width;
              if (koopas[i].kinematics.vx > 0) {
                koopas[i].kinematics.vx = -koopas[i].kinematics.vx;
              }
            } else if (koopas[i].collider.pos.x < 0) {
              koopas[i].collider.pos.x = 0;
              if (koopas[i].kinematics.vx < 0) {
                koopas[i].kinematics.vx = -koopas[i].kinematics.vx;
              }
            }
          }
        }

        //Fireball Movement
        if (fireball.isActive) {
          drawPastBox(fireball);
          fireball.collider.pos.x += fireball.kinematics.vx;
          //Remove fireball after it hits the edge of the screen
          if (fireball.collider.pos.x > WIDTH - fireball.collider.width || fireball.collider.pos.x < 0) {
            fireball.isActive = 0;
          } 
        }
        
        char numLivesChanged = 0;
        char marioLivesChanged = 0;

        //Collision Detection - Koopa + Forcefield
        for (int i = 0; i < MAX_FORCEFIELDS; i++) {
          for (int j = 0; j < MAX_KOOPAS; j++) {
            if (forcefields[i].isActive && isColliding(&forcefields[i].collider, &koopas[j].collider)) {
              koopas[j].isActive = 0;
              drawPastBox(koopas[j]);
              numKoopas--;
            }
          }
        }

        //Collision Detection - Mario + Forcefield
        for (int i = 0; i < MAX_FORCEFIELDS; i++) {
          if (forcefields[i].isActive && isColliding(&forcefields[i].collider, &mario.collider)) {
            forcefields[i].isActive = 0;
            marioLives--;
            hitDuration = FRAME_RATE;
            marioLivesChanged = 1;
          }
        }
        hitDuration--;

        //Collision Detection - Koopa + Goomba
        for (int i = 0; i < MAX_KOOPAS; i++) {
          if (koopas[i].isActive && isColliding(&goomba.collider, &koopas[i].collider) && iframesTime < 0) {
            numLives--;
            koopas[i].isActive = 0;
            drawPastBox(koopas[i]);
            iframesTime = IFRAMES * FRAME_RATE;
            numLivesChanged = 1;
          }
        }

        //Collision Detection - Mario + Goomba
        if (mario.isActive && isColliding(&goomba.collider, &mario.collider) && iframesTime < 0) {
          numLives--;
          iframesTime = IFRAMES * FRAME_RATE;
          numLivesChanged = 1;
        }
        
        //Collision Detection - Fireball + Goomba
        if (fireball.isActive && isColliding(&goomba.collider, &fireball.collider) && iframesTime < 0) {
          numLives--;
          fireball.isActive = 0;
          iframesTime = IFRAMES * FRAME_RATE;
          numLivesChanged = 1;
        }
        iframesTime--;
        
        if (numLives <= 0) {
          state = LOSE;
        } else if (marioLives <= 0) {
          state = WIN;
        }

        sprintf(numLivesStr, "Lives: %d", numLives);
        sprintf(marioLivesStr, "Mario Lives: %d", marioLives);

        // ---------------------------------------------------------------------------
        //                                    DRAW 
        // ---------------------------------------------------------------------------
        
        if (mario.isActive) {
          if (fireball.isActive) {
            if (mario.frames.currentFrame != 5) {
              updateAnimation(&mario.frames);
            } 
          } else {
            mario.frames.currentFrame = 0;
          }
          if (hitDuration > 0) {
            drawImageDMA(mario.collider.pos.y, mario.collider.pos.x, mario.collider.width, mario.collider.height, marioFramePain);
          } else {
            drawAnimation(&mario.frames, mario.collider.pos.x, mario.collider.pos.y);
          }
        }
        
        if (fireball.isActive) {
          drawRectDMA(fireball.collider.pos.y, fireball.collider.pos.x, fireball.collider.width, fireball.collider.height, SKY);
          updateAnimation(&fireball.frames);
          drawAnimation(&fireball.frames, fireball.collider.pos.x, fireball.collider.pos.y);
        }
      
        for (int i = 0; i < MAX_PLATFORMS; i++){
          updateAnimation(&platforms[i].frames);
          drawAnimation(&platforms[i].frames, platforms[i].collider.pos.x, platforms[i].collider.pos.y);
        }

        for (int i = 0; i < MAX_KOOPAS; i++) {
          if (koopas[i].isActive) {
            updateAnimation(&koopas[i].frames);
            drawAnimation(&koopas[i].frames, koopas[i].collider.pos.x, koopas[i].collider.pos.y);
            //drawRectDMA(koopa.collider.pos.y, koopa.collider.pos.x, koopa.collider.width, koopa.collider.height, RED);
            koopas[i].hasChanged = 0;
          }
        }
        
        
        if (goomba.hasChanged) {
          updateAnimation(&goombaShuffle);
          updateAnimation(&goombaShufflePain);
          goomba.hasChanged = 0;
        }

        if (canJump == 0) {
          if ((iframesTime >= 0 && iframesTime % 3 == 0) || iframesTime < 0) {
            drawImageDMA(goomba.collider.pos.y, goomba.collider.pos.x, goomba.collider.width, goomba.collider.height, jumpFrame);
          } else {
            drawImageDMA(goomba.collider.pos.y, goomba.collider.pos.x, goomba.collider.width, goomba.collider.height, jumpFramePain);
          } 
        } else if ((iframesTime >= 0 && iframesTime % 3 == 0) || iframesTime < 0){
          drawAnimation(&goombaShuffle, goomba.collider.pos.x, goomba.collider.pos.y);
        } else {
          drawAnimation(&goombaShufflePain, goomba.collider.pos.x, goomba.collider.pos.y);
        }
        //drawRectDMA(goomba.collider.pos.y, goomba.collider.pos.x, goomba.collider.width, goomba.collider.height, WHITE);

        for (int i = 0; i < MAX_FORCEFIELDS; i++){
          if (forcefields[i].isActive) {
            if (forcefields[i].frames.currentFrame != 2) {
              updateAnimation(&forcefields[i].frames);
            }
            drawAnimation(&forcefields[i].frames, forcefields[i].collider.pos.x, forcefields[i].collider.pos.y);
          }
        }
        
        if (numLivesChanged || timer == 0) {
          drawRectDMA(numLivesPos.y, numLivesPos.x, TEXT_W * strlen(numLivesStr), TEXT_H, SKY);
          drawString(numLivesPos.y, numLivesPos.x, numLivesStr, WHITE);
          numLivesChanged = 0;
        } 

        if (marioLivesChanged || timer == 0) {
          drawRectDMA(marioLivesPos.y, marioLivesPos.x, TEXT_W * strlen(marioLivesStr), TEXT_H, SKY);
          drawString(marioLivesPos.y, marioLivesPos.x, marioLivesStr, RED);
          marioLivesChanged = 0;
        }

        timer++;
        
      break;
        
      case WIN:
        if (winScreenFrames.currentFrame != 10) {
          updateAnimation(&winScreenFrames);
          drawAnimation(&winScreenFrames, 0, 0);
        } else if (!scoreUpdated){
          sprintf(totalScoreStr, "Final Score: %d", 5000000 * numLives / timer);
          drawAnimation(&winScreenFrames, 0, 0);
          drawCenteredString(HEIGHT / 6, 0, WIDTH, HEIGHT, totalScoreStr, 0x28bb);
          scoreUpdated = 1;
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = START;
        }
        // state = ?
        break;
      case LOSE:
        if (loseScreenFrames.currentFrame != 5) {
          updateAnimation(&loseScreenFrames);
          drawAnimation(&loseScreenFrames, 0, 0);
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = START;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}

void drawPastBox(struct object obj) {
  drawRectDMA(obj.collider.pos.y, obj.collider.pos.x, obj.collider.width, obj.collider.height, SKY);
}

